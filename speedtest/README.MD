# SPEEDTEST
найти наименьший индекс i компоненты со значением x в массиве A.
## Линейный поиск 
последовательный просмотр массива с увеличением шаг за шагом той его части, где желаемого элемента не обнаружено:
```pascal
Var A: Array[1..N] Of T;
…
i := 0;
Repeat 
  i := i +1 
Until (A[i] = x) Or (i = N);
If (a[i] <> x) Then WriteLn('В массиве A нет элемента со значением',x);
```
## Метод фиктивного элемента (метод барьера)
позволяет сократить количество сравнений за счет расположения в конце массива искомого элемента:
```pascal
Var A:Array[1..N + 1] Of T;
…
i = 0; A[N + 1] = x;
Repeat 
  i := i + 1
Until (a[i] = x);
If (i>N) Then WriteLn('В массиве A нет элемента со значением',x);
```
## Бинарный поиск
метод, основанный на факте, что поиск можно значительно ускорить, если компоненты массива уже отсортированы. Этот метод также называют методом повторного деления пополам интервала, в котором находится нужный элемент. При этом максимальное число требуемых сравнений log2 N.
```pascal
i := 1; j := N;
Repeat
	k := (i + j) Div 2;
	If (i > a[k]) Then i := k + 1 
      Else j := k - 1;
Until (a[k] = x) Or (i > j);
```

### Примечание
В задаче рассматриваются три алгоритма. Ввести большое количество элементов и вывести время работы алгоритма. Сравнить, какой из алгоритмов является самым быстрым, какой – самым медленным.
